// Controller administrativo principal
import { ImageOptimizationController } from './image-optimization-controller.js';
import { ProductAdminController } from './product-admin-controller.js';
import { GalleryAdminController } from './gallery-admin-controller.js';
import { TagsAdminController } from './tags-admin-controller.js';

export class AdminController {
    constructor(database, view) {
        this.database = database;
        this.view = view;
        this.currentSection = 'dashboard';
        
        // Controllers especializados
        this.imageOptController = new ImageOptimizationController(database, view);
        this.productController = new ProductAdminController(database, view, this);
        this.galleryController = new GalleryAdminController(database, view, this);
        this.tagsController = new TagsAdminController(database, view, this);
        
        // Expor globalmente para onclick dos botões
        window.imageOptController = this.imageOptController;
        window.productController = this.productController;
        window.galleryController = this.galleryController;
        window.tagsController = this.tagsController;
    }

    init() {
        this.setupEventListeners();
        this.showDashboard();
    }
    
    setupEventListeners() {
        // Elementos DOM
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        
        // Função auxiliar para toggle sidebar
        const toggleSidebar = (show) => {
            if (show) {
                sidebar?.classList.remove('-translate-x-full');
                sidebarOverlay?.classList.remove('hidden');
            } else {
                sidebar?.classList.add('-translate-x-full');
                sidebarOverlay?.classList.add('hidden');
            }
        };
        
        // Mobile menu listeners
        document.getElementById('mobileMenuBtn')?.addEventListener('click', () => toggleSidebar(true));
        document.getElementById('closeSidebarBtn')?.addEventListener('click', () => toggleSidebar(false));
        sidebarOverlay?.addEventListener('click', () => toggleSidebar(false));
        
        // Navigation listeners
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                const section = item.dataset.section;
                this.switchSection(section);
                
                // Close sidebar on mobile após seleção
                if (window.innerWidth < 1024) {
                    toggleSidebar(false);
                }
            });
        });
        
        // Global action buttons
        document.getElementById('exportBtn')?.addEventListener('click', () => {
            this.database.exportData();
            this.view.showNotification('Dados exportados com sucesso!');
        });
        
        document.getElementById('viewSiteBtn')?.addEventListener('click', () => {
            window.open('/index.html', '_blank');
        });
        
        // Setup drag and drop
        this.setupDragAndDrop();
    }

    async switchSection(section) {
        this.currentSection = section;
        
        // Update navigation active state
        document.querySelectorAll('.nav-item').forEach(item => {
            if (item.dataset.section === section) {
                item.classList.add('bg-orange-50', 'text-orange-600');
            } else {
                item.classList.remove('bg-orange-50', 'text-orange-600');
            }
        });

        // Update section title
        const titles = {
            dashboard: 'Dashboard',
            products: 'Produtos',
            categories: 'Categorias',
            gallery: 'Galeria de Imagens',
            settings: 'Configurações'
        };
        document.getElementById('sectionTitle').textContent = titles[section];

        // Load section content
        switch(section) {
            case 'dashboard':
                this.showDashboard();
                break;
            case 'products':
                await this.productController.showProducts();
                break;
            case 'categories':
                this.showCategories();
                break;
            case 'gallery':
                await this.galleryController.showGallery();
                break;
            case 'settings':
                this.showSettings();
                break;
        }
    }

    async showDashboard() {
        // Show loading skeleton immediately
        this.view.showLoadingSkeleton();
        
        try {
            // Ensure data is loaded
            await this.database.loadData();
            
            // Get fresh statistics
            const stats = this.database.getStatistics();
            
            // Show dashboard immediately after loading
            this.view.showDashboard(stats);
            this.setupDashboardClickListeners();
            
        } catch (error) {
            console.error('❌ Dashboard load failed:', error);
            this.view.showNotification('Erro ao carregar dashboard', 'error');
            
            // Show dashboard with fallback data
            const fallbackStats = {
                totalProducts: 0,
                totalCategories: 0, 
                activeProducts: 0,
                onSaleProducts: 0,
                totalImages: 0,
                restaurantName: 'Menu Online'
            };
            
            this.view.showDashboard(fallbackStats);
            this.setupDashboardClickListeners();
        }
    }
        
    setupDashboardClickListeners() {
        // Setup refresh button
        const refreshBtn = document.getElementById('refreshDataBtn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', async () => {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = `
                    <svg class="animate-spin w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                    </svg>
                    Atualizando...
                `;
                
                await this.database.forceReload();
                this.view.showNotification('Dados atualizados com sucesso!', 'success');
                this.showDashboard();
            });
        }
        
        // Setup dashboard card navigation
        document.querySelectorAll('.dashboard-card').forEach(card => {
            card.addEventListener('click', () => {
                const action = card.dataset.action;
                if (action === 'goto-products') {
                    this.switchSection('products');
                } else if (action === 'goto-products-active') {
                    this.switchSection('products');
                    // Apply active filter after loading
                    setTimeout(() => {
                        const statusFilter = document.getElementById('statusFilter');
                        if (statusFilter) {
                            statusFilter.value = 'active';
                            statusFilter.dispatchEvent(new Event('change'));
                        }
                    }, 100);
                } else if (action === 'goto-categories') {
                    this.switchSection('categories');
                } else if (action === 'goto-products-featured') {
                    this.switchSection('products');
                    // Apply featured filter after loading
                    setTimeout(() => {
                        const featuredFilter = document.getElementById('featuredFilter');
                        if (featuredFilter) {
                            featuredFilter.value = 'featured';
                            featuredFilter.dispatchEvent(new Event('change'));
                        }
                    }, 100);
                }
            });
        });
        
        // Setup quick actions
        document.querySelectorAll('.quick-action-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const action = btn.dataset.action;
                if (action === 'add-product') {
                    this.switchSection('products');
                    setTimeout(() => this.productController.showProductForm(), 100);
                } else if (action === 'add-category') {
                    this.switchSection('categories');
                    setTimeout(() => this.showCategoryForm(), 100);
                } else if (action === 'backup') {
                    this.database.exportData();
                    this.view.showNotification('Backup realizado com sucesso!');
                }
            });
        });
    }
    showCategories() {
        const categories = this.database.getCategories();
        this.view.showCategories(categories);
        
        // Add category button
        document.getElementById('addCategoryBtn').addEventListener('click', () => {
            this.showCategoryForm();
        });
        
        // Edit buttons
        document.querySelectorAll('.edit-category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const category = this.database.getCategoryById(btn.dataset.id);
                this.showCategoryForm(category);
            });
        });
        
        // Delete buttons
        document.querySelectorAll('.delete-category-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                this.showCategoryDeleteConfirmation(btn.dataset.id);
            });
        });
        
        // Setup drag and drop for categories
        this.setupCategoryDragAndDrop();
    }

    showCategoryDeleteConfirmation(categoryId) {
        const category = this.database.getCategoryById(categoryId);
        const products = this.database.getProducts({ categoryId: categoryId });
        
        if (!category) return;
        
        const confirmationHtml = `
            <div class="text-center space-y-4">
                <div class="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-red-100 mb-4">
                    <svg class="h-6 w-6 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"></path>
                    </svg>
                </div>
                
                <h3 class="text-lg font-semibold text-gray-900 mb-2">Deletar Categoria</h3>
                <p class="text-sm text-gray-600 mb-4">Você está prestes a deletar a categoria:</p>
                
                <div class="bg-red-50 border border-red-200 rounded-lg p-3 mb-4">
                    <p class="font-semibold text-red-800">"${category.name}"</p>
                </div>
                
                ${products.length > 0 ? `
                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
                        <div class="flex items-start">
                            <svg class="w-5 h-5 text-yellow-600 mt-0.5 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"></path>
                            </svg>
                            <div class="text-left">
                                <p class="text-sm font-medium text-yellow-800 mb-2">⚠️ Atenção!</p>
                                <p class="text-sm text-yellow-700 mb-2">
                                    Ao deletar esta categoria, <strong>${products.length} produto${products.length > 1 ? 's' : ''}</strong> 
                                    ficar${products.length > 1 ? 'ão' : 'á'} sem categoria e você deverá colocá-l${products.length > 1 ? 'os' : 'o'} 
                                    novamente dentro de uma nova categoria.
                                </p>
                                <div class="text-xs text-yellow-600 space-y-1">
                                    ${products.slice(0, 3).map(p => `<div>• ${p.name}</div>`).join('')}
                                    ${products.length > 3 ? `<div>• ... e mais ${products.length - 3} produto${products.length - 3 > 1 ? 's' : ''}</div>` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                ` : `
                    <div class="bg-green-50 border border-green-200 rounded-lg p-3 mb-4">
                        <p class="text-sm text-green-700">✅ Esta categoria não possui produtos. Pode ser deletada com segurança.</p>
                    </div>
                `}
                
                <p class="text-sm text-gray-600 mb-6">Você tem certeza?</p>
                
                <div class="flex flex-col sm:flex-row gap-3 justify-center">
                    <button 
                        id="confirmCategoryDeleteBtn" 
                        class="px-6 py-2 text-sm text-white bg-gray-600 border border-gray-600 rounded-md hover:bg-gray-700 transition-colors"
                        data-category-id="${categoryId}"
                    >
                        Sim, deletar
                    </button>
                    <button 
                        id="cancelCategoryDeleteBtn" 
                        class="px-6 py-2 text-sm text-white bg-orange-600 rounded-md hover:bg-orange-700 font-medium transition-colors"
                    >
                        Não, cancelar
                    </button>
                </div>
            </div>
        `;
        
        this.view.showModal('Confirmar Deleção', confirmationHtml);
        
        // Handle confirm deletion
        document.getElementById('confirmCategoryDeleteBtn').addEventListener('click', (e) => {
            const categoryId = e.target.dataset.categoryId;
            this.database.deleteCategory(categoryId);
            this.view.showNotification('Categoria excluída com sucesso!', 'success');
            this.view.closeModal();
            this.showCategories();
        });
        
        // Handle cancel
        document.getElementById('cancelCategoryDeleteBtn').addEventListener('click', () => {
            this.view.closeModal();
        });
    }

    showCategoryForm(category = null) {
        const isEdit = category !== null;
        
        const formHtml = `
            <form id="categoryForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Nome da Categoria *</label>
                    <input 
                        type="text" 
                        id="categoryName" 
                        value="${category?.name || ''}"
                        required
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                    >
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Ordem de Exibicao</label>
                    <input 
                        type="number" 
                        id="categoryOrder" 
                        value="${category?.order || ''}"
                        min="1"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                    >
                </div>
                
                <div class="flex items-center">
                    <input 
                        type="checkbox" 
                        id="categoryActive" 
                        ${category?.active !== false ? 'checked' : ''}
                        class="rounded border-gray-300 text-orange-600 focus:ring-orange-500"
                    >
                    <label for="categoryActive" class="ml-2 text-sm text-gray-700">
                        Categoria ativa
                    </label>
                </div>
                
                <div class="flex justify-end space-x-3 pt-4">
                    <button 
                        type="button" 
                        id="cancelBtn"
                        class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
                    >
                        Cancelar
                    </button>
                    <button 
                        type="submit" 
                        class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700"
                    >
                        ${isEdit ? 'Atualizar' : 'Adicionar'} Categoria
                    </button>
                </div>
            </form>
        `;
        
        this.view.showModal(isEdit ? 'Editar Categoria' : 'Adicionar Categoria', formHtml);
        
        // Handle form submission
        document.getElementById('categoryForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.saveCategory(category?.id);
        });
        
        // Handle cancel
        document.getElementById('cancelBtn').addEventListener('click', () => {
            this.view.closeModal();
        });
    }

    saveCategory(categoryId = null) {
        const categoryData = {
            name: document.getElementById('categoryName').value,
            order: parseInt(document.getElementById('categoryOrder').value) || 999,
            active: document.getElementById('categoryActive').checked
        };
        
        if (categoryId) {
            this.database.updateCategory(categoryId, categoryData);
            this.view.showNotification('Categoria atualizada com sucesso!');
        } else {
            this.database.addCategory(categoryData);
            this.view.showNotification('Categoria adicionada com sucesso!');
        }
        
        this.view.closeModal();
        this.showCategories();
    }

    async showSettings() {
        const restaurant = this.database.getRestaurant();
        this.view.showSettings(restaurant);
        
        // Restaurant form
        document.getElementById('restaurantForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.saveRestaurantSettings();
        });

        // Image optimization
        await this.imageOptController.setupImageOptimization();
        
        // Export data
        document.getElementById('exportDataBtn').addEventListener('click', () => {
            this.database.exportData();
            this.view.showNotification('Dados exportados com sucesso!');
        });
        
        // Import data
        document.getElementById('importDataBtn').addEventListener('click', () => {
            const fileInput = document.getElementById('importFile');
            const file = fileInput.files[0];
            
            if (!file) {
                alert('Selecione um arquivo para importar');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    if (this.database.importData(e.target.result)) {
                        this.view.showNotification('Dados importados com sucesso!');
                        setTimeout(() => location.reload(), 1500);
                    } else {
                        this.view.showNotification('Erro ao importar dados', 'error');
                    }
                } catch (error) {
                    this.view.showNotification('Arquivo inválido', 'error');
                }
            };
            reader.readAsText(file);
        });
    }

    async showGallery() {
        
        // Always check if cache is valid (includes cross-browser modification check)
        const cacheValid = this.database.cache.isValid();
        
        if (!cacheValid) {
            await this.database.loadData();
        }
        
        // Show current data
        const images = this.database.getGalleryImages();
        
        this.view.showGallery(images, false);
        this.selectedImages = new Set();
        this.isSelectionMode = false; // Controla se está em modo seleção
        this.hadSelections = false; // Controla se já teve seleções para evitar auto-exit prematuro
        this.setupGalleryEventListeners();
    }
    
    setupGalleryEventListeners() {
        // Upload multiple images
        const uploadBtn = document.getElementById('uploadImagesBtn');
        if (uploadBtn) {
            uploadBtn.addEventListener('click', () => {
                this.showImageUploadForm();
            });
        }
        
        // Upload from URL
        const uploadUrlBtn = document.getElementById('uploadFromUrlBtn');
        if (uploadUrlBtn) {
            uploadUrlBtn.addEventListener('click', () => {
                this.showUrlUploadForm();
            });
        }
        
        // Search functionality
        const searchInput = document.getElementById('gallerySearch');
        if (searchInput) {
            let searchTimeout;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    this.filterGalleryImages(e.target.value);
                }, 300);
            });
        }
        
        // Image selection checkboxes (hidden, only for state)
        document.querySelectorAll('.image-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                this.galleryController.toggleImageSelection(e.target.dataset.imageId, e.target.checked);
            });
        });
        // Gallery image card clicks - só seleciona se já estiver em modo seleção
        document.querySelectorAll('.gallery-image-card').forEach(card => {
            let longPressTimer;
            let startPosition = { x: 0, y: 0 };
            let hasMoved = false;
            let wasLongPress = false;
            let longPressActive = false; // Nova flag para controlar se long press está ativo
            let isCurrentlyPressed = false; // Flag para verificar se ainda está pressionando
            const moveThreshold = 10; // pixels - igual ao iPhone
            
            // Long press para entrar em modo seleção (iPhone-style) - Mouse events
            card.addEventListener('mousedown', (e) => {
                // Long press funciona em qualquer lugar da imagem (inclusive sobre botões)
                startPosition = { x: e.clientX, y: e.clientY };
                hasMoved = false;
                wasLongPress = false;
                longPressActive = true; // Ativa o long press
                isCurrentlyPressed = true; // Marca que está pressionando
                
                longPressTimer = setTimeout(() => {
                    // Só executa se long press ativo, não moveu E ainda está pressionando
                    if (longPressActive && !hasMoved && isCurrentlyPressed) {
                        wasLongPress = true;
                        const imageId = card.dataset.imageId;
                        const checkbox = card.querySelector('.image-checkbox');
                        if (checkbox) {
                            // Primeiro entra em modo seleção
                            this.enterSelectionMode();
                            // Depois seleciona a imagem
                            checkbox.checked = true;
                            this.galleryController.toggleImageSelection(imageId, true);
                        }
                    } else {
                    }
                }, 350); // 350ms mais responsivo como iPhone real
            });
            
            card.addEventListener('mousemove', (e) => {
                if (longPressTimer) {
                    const distance = Math.sqrt(
                        Math.pow(e.clientX - startPosition.x, 2) + 
                        Math.pow(e.clientY - startPosition.y, 2)
                    );
                    
                    if (distance > moveThreshold) {
                        hasMoved = true;
                        longPressActive = false; // Desativa o long press
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                        wasLongPress = false; // Reset flag se cancelou por movimento
                    }
                }
            });
            
            card.addEventListener('mouseup', () => {
                isCurrentlyPressed = false; // Não está mais pressionando
                if (longPressTimer) {
                    longPressActive = false; // Desativa o long press
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    wasLongPress = false; // Reset flag se cancelou
                }
            });
            
            card.addEventListener('mouseleave', () => {
                isCurrentlyPressed = false; // Não está mais pressionando
                if (longPressTimer) {
                    longPressActive = false; // Desativa o long press
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    wasLongPress = false; // Reset flag se cancelou
                }
            });
            
            // Long press para mobile - Touch events com detecção de movimento
            card.addEventListener('touchstart', (e) => {
                // Long press funciona em qualquer lugar da imagem (inclusive sobre botões)
                const touch = e.touches[0];
                startPosition = { x: touch.clientX, y: touch.clientY };
                hasMoved = false;
                wasLongPress = false;
                longPressActive = true; // Ativa o long press
                isCurrentlyPressed = true; // Marca que está pressionando
                
                longPressTimer = setTimeout(() => {
                    // Só executa se long press ativo, não moveu E ainda está pressionando
                    if (longPressActive && !hasMoved && isCurrentlyPressed) {
                        wasLongPress = true;
                        const imageId = card.dataset.imageId;
                        const checkbox = card.querySelector('.image-checkbox');
                        if (checkbox) {
                            // Primeiro entra em modo seleção
                            this.enterSelectionMode();
                            // Depois seleciona a imagem
                            checkbox.checked = true;
                            this.galleryController.toggleImageSelection(imageId, true);
                        }
                        
                        // Vibração no mobile (se disponível)
                        if (navigator.vibrate) {
                            navigator.vibrate(50);
                        }
                    } else {
                    }
                }, 350); // 350ms mais responsivo como iPhone real
            });
            
            card.addEventListener('touchmove', (e) => {
                if (longPressTimer) {
                    const touch = e.touches[0];
                    const distance = Math.sqrt(
                        Math.pow(touch.clientX - startPosition.x, 2) + 
                        Math.pow(touch.clientY - startPosition.y, 2)
                    );
                    
                    if (distance > moveThreshold) {
                        hasMoved = true;
                        longPressActive = false; // Desativa o long press
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                        wasLongPress = false; // Reset flag se cancelou por movimento
                    }
                }
            });
            
            card.addEventListener('touchend', () => {
                isCurrentlyPressed = false; // Marca que não está mais pressionando
                if (longPressTimer) {
                    longPressActive = false; // Desativa o long press
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    wasLongPress = false; // Reset flag se cancelou
                }
            });
            
            card.addEventListener('touchcancel', () => {
                isCurrentlyPressed = false; // Marca que não está mais pressionando
                if (longPressTimer) {
                    longPressActive = false; // Desativa o long press
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                    wasLongPress = false; // Reset flag se cancelou
                }
            });
            
            // Clique normal - só seleciona se já estiver em modo seleção
            card.addEventListener('click', (e) => {
                // Se foi long press, não executa clique normal
                if (wasLongPress) {
                    wasLongPress = false; // Reset para próximo clique
                    return;
                }
                
                // Cancela qualquer timer pendente
                if (longPressTimer) {
                    clearTimeout(longPressTimer);
                    longPressTimer = null;
                }
                
                return this.handleNormalClick(e, card);
            });
        });
        
        // Método separado para lidar com clique normal
        this.handleNormalClick = (e, card) => {
            // Don't trigger if clicking on buttons inside the card
            if (e.target.closest('button')) {
                return;
            }
            
            // Só seleciona se já estiver em modo seleção
            if (this.isSelectionMode) {
                const imageId = card.dataset.imageId;
                const checkbox = card.querySelector('.image-checkbox');
                if (checkbox) {
                    checkbox.checked = !checkbox.checked;
                    this.galleryController.toggleImageSelection(imageId, checkbox.checked);
                }
            } else {
                // Clique normal - mostra botões no mobile (simulando hover)
                this.showMobileButtons(card);
            }
        };
        // Select image buttons - entra em modo seleção
        document.querySelectorAll('.select-image-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const imageId = btn.dataset.imageId;
                
                // Entra em modo seleção
                this.enterSelectionMode();
                
                // Seleciona a imagem clicada
                const checkbox = document.querySelector(`input[data-image-id="${imageId}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                    this.galleryController.toggleImageSelection(imageId, true);
                }
            });
        });
        
        // Edit image buttons
        const editButtons = document.querySelectorAll('.edit-image-btn');
        
        editButtons.forEach((btn, index) => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling
                const imageId = btn.dataset.imageId;
                const image = this.database.getGalleryImageById(imageId);
                if (image) {
                    this.showImageEditForm(image);
                } else {
                    console.error('Imagem não encontrada com ID:', imageId);
                }
            });
        });
        
        // Delete image buttons
        document.querySelectorAll('.delete-image-btn').forEach(btn => {
            btn.addEventListener('click', async (e) => {
                e.stopPropagation(); // Prevent event bubbling
                if (confirm('Tem certeza que deseja excluir esta imagem?')) {
                    try {
                        const imageId = btn.dataset.imageId;
                        const imageCard = btn.closest('.gallery-image-card');
                        // Immediate visual feedback
                        if (imageCard) {
                            imageCard.style.opacity = '0.5';
                            imageCard.style.pointerEvents = 'none';
                            imageCard.style.transform = 'scale(0.95)';
                            imageCard.style.transition = 'all 0.3s ease';
                            
                            // Add deleting indicator
                            const overlay = document.createElement('div');
                            overlay.className = 'delete-overlay absolute inset-0 bg-red-500 bg-opacity-75 flex items-center justify-center text-white font-semibold z-50 rounded';
                            overlay.innerHTML = `
                                <div class="text-center">
                                    <svg class="animate-spin mx-auto mb-2 h-6 w-6" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                    </svg>
                                    <div class="text-xs">Excluindo...</div>
                                </div>
                            `;
                            imageCard.appendChild(overlay);
                        }
                        
                        // Perform actual delete in background
                        await this.database.deleteGalleryImage(imageId);
                        
                        // Smooth removal animation
                        if (imageCard) {
                            imageCard.style.transform = 'scale(0)';
                            imageCard.style.opacity = '0';
                            
                            setTimeout(() => {
                                imageCard.remove();
                                this.view.showNotification('Imagem excluída com sucesso!', 'success');
                                
                                // Update counters
                                const remainingImages = document.querySelectorAll('.gallery-image-card').length;
                                const counterElement = document.querySelector('.text-sm.text-gray-500');
                                if (counterElement) {
                                    counterElement.textContent = `${remainingImages} ${remainingImages === 1 ? 'imagem' : 'imagens'}`;
                                }
                            }, 300);
                        }
                    } catch (error) {
                        console.error('❌ Erro ao deletar imagem:', error);
                        this.view.showNotification('Erro ao excluir imagem', 'error');
                    }
                }
            });
        });
    }
    
    toggleImageSelection(imageId, isSelected) {
        const card = document.querySelector(`[data-image-id="${imageId}"]`);
        const overlay = card.querySelector('.selection-overlay');
        const indicator = card.querySelector('.selected-indicator');
        
        const checkbox = card.querySelector('.selection-checkbox');
        const checkboxCircle = checkbox.querySelector('div');
        
        if (isSelected) {
            this.selectedImages.add(imageId);
            // Apply orange selection visual effects
            overlay.classList.add('bg-opacity-20');
            overlay.classList.add('bg-orange-500');
            checkboxCircle.classList.remove('bg-white', 'border-white');
            checkboxCircle.classList.add('bg-orange-500', 'border-orange-500');
            indicator.classList.remove('opacity-0', 'scale-0');
            indicator.classList.add('opacity-100', 'scale-100');
            card.classList.add('ring-2', 'ring-orange-500');
        } else {
            this.selectedImages.delete(imageId);
            // Remove orange selection visual effects
            overlay.classList.remove('bg-opacity-20', 'bg-orange-500');
            checkboxCircle.classList.remove('bg-orange-500', 'border-orange-500');
            checkboxCircle.classList.add('bg-white', 'border-white');
            indicator.classList.add('opacity-0', 'scale-0');
            indicator.classList.remove('opacity-100', 'scale-100');
            card.classList.remove('ring-2', 'ring-orange-500');
        }
        
        this.updateSelectionCounter();
        this.updateNonSelectedImagesVisual();
        
        // Mostra menu contextual quando há imagens selecionadas
        if (this.selectedImages.size > 0) {
            // Pequeno delay para mostrar o menu após a seleção
            setTimeout(() => {
                this.showSelectionContextMenu();
            }, 200);
        }
    }
    
    updateSelectionCounter() {
        const selectedCount = this.selectedImages.size;
        
        // Só faz auto-exit se o usuário realmente desmarcou todas as seleções
        // Evita auto-exit imediato quando entra no modo através de long press
        if (this.isSelectionMode && selectedCount === 0 && this.hadSelections) {
            // Evita auto-exit se acabou de entrar no modo seleção (debounce)
            if (this.lastSelectionModeEntry && (Date.now() - this.lastSelectionModeEntry) < 350) {
                return;
            }
            
            // Delay para evitar conflito com toggleImageSelection
            setTimeout(() => {
                if (this.selectedImages.size === 0 && this.isSelectionMode && this.hadSelections) {
                    this.exitSelectionMode();
                }
            }, 100); // Delay menor mas suficiente
            return;
        }
        
        // Marca que já teve seleções para controlar o auto-exit
        if (selectedCount > 0) {
            this.hadSelections = true;
        }
        
        if (this.isSelectionMode || selectedCount > 0) {
            // Mostrar todas as checkboxes quando em modo seleção
            document.querySelectorAll('.selection-checkbox').forEach(checkbox => {
                checkbox.classList.remove('opacity-0');
                checkbox.classList.add('opacity-100');
            });
            
            // Esconder botões de hover quando em modo seleção  
            document.querySelectorAll('.action-buttons').forEach(btnGroup => {
                btnGroup.classList.add('hidden');
            });
            
        } else {
            // Esconder todas as checkboxes quando não está em modo seleção
            document.querySelectorAll('.selection-checkbox').forEach(checkbox => {
                checkbox.classList.remove('opacity-100');
                checkbox.classList.add('opacity-0');
            });
            
            // Mostrar botões de hover quando não está em modo seleção
            document.querySelectorAll('.action-buttons').forEach(btnGroup => {
                btnGroup.classList.remove('hidden');
            });
        }
    }
    
    updateNonSelectedImagesVisual() {
        const hasSelection = this.selectedImages.size > 0;
        
        document.querySelectorAll('.gallery-image-card').forEach(card => {
            const imageId = card.dataset.imageId;
            const overlay = card.querySelector('.selection-overlay');
            
            if (hasSelection && !this.selectedImages.has(imageId)) {
                // Darken non-selected images
                overlay.classList.add('bg-opacity-40', 'bg-gray-800');
                card.classList.add('opacity-60');
            } else if (!this.selectedImages.has(imageId)) {
                // Remove darkening if no selection
                overlay.classList.remove('bg-opacity-40', 'bg-gray-800');
                card.classList.remove('opacity-60');
            }
        });
    }
    
    selectAllImages() {
        const allImages = document.querySelectorAll('.gallery-image-card');
        const isAllSelected = this.selectedImages.size === allImages.length;
        
        if (isAllSelected) {
            // Deselect all if all are selected
            allImages.forEach(card => {
                const imageId = card.dataset.imageId;
                const checkbox = card.querySelector('.image-checkbox');
                if (checkbox) {
                    checkbox.checked = false;
                    this.galleryController.toggleImageSelection(imageId, false);
                }
            });
            
        } else {
            // Select all images
            allImages.forEach(card => {
                const imageId = card.dataset.imageId;
                const checkbox = card.querySelector('.image-checkbox');
                if (checkbox && !this.selectedImages.has(imageId)) {
                    checkbox.checked = true;
                    this.galleryController.toggleImageSelection(imageId, true);
                }
            });
            
        }
    }
    
    enterSelectionMode() {
        this.isSelectionMode = true;
        this.lastSelectionModeEntry = Date.now(); // Marca timestamp de entrada
        
        // Força atualização visual para mostrar checkboxes
        this.updateSelectionCounter();
    }
    
    exitSelectionMode() {
        this.isSelectionMode = false;
        this.selectedImages.clear();
        this.hadSelections = false; // Reset para próxima vez
        // Limpa todas as seleções visuais
        document.querySelectorAll('.image-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
        
        // Limpa efeitos visuais de seleção
        document.querySelectorAll('.gallery-image-card').forEach(card => {
            const overlay = card.querySelector('.selection-overlay');
            const checkboxCircle = card.querySelector('.selection-checkbox div');
            const indicator = card.querySelector('.selected-indicator');
            
            if (overlay) overlay.classList.remove('bg-opacity-20', 'bg-orange-500');
            if (checkboxCircle) {
                checkboxCircle.classList.remove('bg-orange-500', 'border-orange-500');
                checkboxCircle.classList.add('bg-white', 'border-white');
            }
            if (indicator) {
                indicator.classList.add('opacity-0', 'scale-0');
                indicator.classList.remove('opacity-100', 'scale-100');
            }
            card.classList.remove('ring-2', 'ring-orange-500');
        });
        
        // Atualiza visual
        this.updateSelectionCounter();
        this.updateNonSelectedImagesVisual();
    }
    
    showMobileButtons(card) {
        // Remove active state de outros cards
        document.querySelectorAll('.gallery-image-card').forEach(c => {
            c.classList.remove('mobile-active');
        });
        
        // Adiciona state ativo para mostrar botões no mobile
        card.classList.add('mobile-active');
        
        // Remove depois de alguns segundos
        setTimeout(() => {
            card.classList.remove('mobile-active');
        }, 3000);
    }
    
    showSelectionContextMenu() {
        // Remove menu anterior se existir
        const existingMenu = document.getElementById('selection-context-menu');
        if (existingMenu) {
            existingMenu.remove();
        }
        
        const selectedCount = this.selectedImages.size;
        if (selectedCount === 0) return;
        
        // Cria menu contextual mais leve com transparência
        const menu = document.createElement('div');
        menu.id = 'selection-context-menu';
        menu.className = 'fixed bottom-20 left-1/2 transform -translate-x-1/2 bg-white bg-opacity-90 backdrop-blur-sm rounded-lg shadow-lg border border-gray-200 border-opacity-50 z-50 p-2 flex gap-2';
        
        // Botão Cancelar (sempre presente)
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'flex items-center gap-2 px-4 py-3 hover:bg-gray-50 hover:bg-opacity-60 rounded-lg transition-all duration-200';
        cancelBtn.innerHTML = `
            <svg class="w-5 h-5 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
            </svg>
            <span class="text-sm font-medium text-gray-600">Cancelar</span>
        `;
        
        // Botão Selecionar Todas (só aparece se nem todas estão selecionadas)
        const selectAllBtn = document.createElement('button');
        const totalImages = document.querySelectorAll('.gallery-image-card').length;
        const allSelected = selectedCount === totalImages;
        
        if (!allSelected) {
            selectAllBtn.className = 'flex items-center gap-2 px-4 py-3 hover:bg-orange-50 hover:bg-opacity-60 rounded-lg transition-all duration-200';
            selectAllBtn.innerHTML = `
                <svg class="w-5 h-5 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <span class="text-sm font-medium text-orange-600">Selecionar Todas</span>
            `;
        }
        
        // Botão Excluir
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'flex items-center gap-2 px-4 py-3 hover:bg-red-50 hover:bg-opacity-60 rounded-lg transition-all duration-200';
        deleteBtn.innerHTML = `
            <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
            </svg>
            <span class="text-sm font-medium text-red-600">Excluir (${selectedCount})</span>
        `;
        
        // Event listeners
        cancelBtn.addEventListener('click', () => {
            this.exitSelectionMode();
            menu.remove();
        });
        
        if (!allSelected) {
            selectAllBtn.addEventListener('click', () => {
                this.selectAllImages();
                menu.remove();
            });
        }
        
        deleteBtn.addEventListener('click', () => {
            this.deleteSelectedImages();
            menu.remove();
        });
        
        // Adiciona botões ao menu
        menu.appendChild(cancelBtn);
        if (!allSelected) {
            menu.appendChild(selectAllBtn);
        }
        menu.appendChild(deleteBtn);
        
        // Adiciona ao DOM
        document.body.appendChild(menu);
        
        // Remove menu ao clicar fora
        setTimeout(() => {
            document.addEventListener('click', (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                }
            }, { once: true });
        }, 100);
        
        // Auto-remove após 8 segundos
        setTimeout(() => {
            if (menu.parentNode) {
                menu.remove();
            }
        }, 8000);
    }
    
    shareSelectedImages() {
        // Implementar compartilhamento
        this.view.showNotification(`Compartilhando ${this.selectedImages.size} imagens...`, 'success');
    }
    
    copySelectedImages() {
        // Implementar cópia
        this.view.showNotification(`${this.selectedImages.size} imagens copiadas!`, 'success');
    }
    
    async deleteSelectedImages() {
        if (this.selectedImages.size === 0) return;
        
        const count = this.selectedImages.size;
        const message = count === 1 ? 
            'Tem certeza que deseja excluir esta imagem?' : 
            `Tem certeza que deseja excluir ${count} imagens?`;
            
        if (confirm(message)) {
            // Mostrar feedback visual durante exclusão
            this.showDeletionProgress(count);
            
            let deletedCount = 0;
            
            // Delete all selected images (await each one)
            for (const imageId of this.selectedImages) {
                try {
                    // Adicionar overlay de "excluindo" na imagem específica
                    this.addDeletingOverlay(imageId);
                    
                    await this.database.deleteGalleryImage(imageId);
                    deletedCount++;
                    
                    // Atualizar progresso
                    this.updateDeletionProgress(deletedCount, count);
                    
                } catch (error) {
                    console.error(`❌ Erro ao deletar imagem ${imageId}:`, error);
                }
            }
            
            // Remover overlay de progresso
            this.hideDeletionProgress();
            
            this.view.showNotification(`${deletedCount} imagem(ns) excluída(s) com sucesso!`);
            await this.galleryController.showGallery(); // Refresh gallery
        }
    }
    
    showDeletionProgress(totalCount) {
        // Criar overlay global de progresso de exclusão
        const overlay = document.createElement('div');
        overlay.id = 'deletion-progress-overlay';
        overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        
        overlay.innerHTML = `
            <div class="bg-white rounded-lg p-6 mx-4 max-w-sm text-center shadow-2xl">
                <div class="mb-4">
                    <svg class="w-12 h-12 text-red-600 mx-auto mb-3 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                    <h3 class="text-lg font-semibold text-gray-900 mb-2">Excluindo imagens</h3>
                    <p class="text-sm text-gray-600" id="deletion-status">Preparando exclusão...</p>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-3">
                    <div id="deletion-progress-bar" class="bg-red-600 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <p class="text-xs text-gray-500 mt-2" id="deletion-counter">0 de ${totalCount}</p>
            </div>
        `;
        
        document.body.appendChild(overlay);
    }
    
    updateDeletionProgress(deletedCount, totalCount) {
        const statusElement = document.getElementById('deletion-status');
        const progressBar = document.getElementById('deletion-progress-bar');
        const counterElement = document.getElementById('deletion-counter');
        
        if (statusElement) {
            statusElement.textContent = `Excluindo imagem ${deletedCount} de ${totalCount}...`;
        }
        
        if (progressBar) {
            const percentage = (deletedCount / totalCount) * 100;
            progressBar.style.width = `${percentage}%`;
        }
        
        if (counterElement) {
            counterElement.textContent = `${deletedCount} de ${totalCount}`;
        }
    }
    
    hideDeletionProgress() {
        const overlay = document.getElementById('deletion-progress-overlay');
        if (overlay) {
            overlay.remove();
        }
    }
    
    addDeletingOverlay(imageId) {
        const imageCard = document.querySelector(`[data-image-id="${imageId}"]`);
        if (imageCard) {
            // Remove overlay existente se houver
            const existingOverlay = imageCard.querySelector('.deleting-overlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            // Adicionar overlay de "excluindo"
            const overlay = document.createElement('div');
            overlay.className = 'deleting-overlay absolute inset-0 bg-red-500 bg-opacity-75 flex items-center justify-center text-white font-semibold z-50 rounded';
            overlay.innerHTML = `
                <div class="text-center">
                    <svg class="animate-spin mx-auto mb-2 h-6 w-6" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <div class="text-xs">Excluindo...</div>
                </div>
            `;
            imageCard.appendChild(overlay);
        }
    }
    
    showImageEditForm(image) {
        const currentTags = image.tags || [];
        const allTags = this.database.getAllTags();
        
        const formHtml = `
            <form id="imageEditForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Nome da Imagem</label>
                    <input 
                        type="text" 
                        id="imageName" 
                        value="${image.name || ''}"
                        placeholder="Nome descritivo da imagem"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                    >
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Tags</label>
                    
                    <!-- Selected tags -->
                    <div id="selectedTags" class="flex flex-wrap gap-2 mb-2 min-h-[32px] p-2 border border-gray-300 rounded-md">
                        ${currentTags.map(tag => `
                            <span class="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-orange-100 text-orange-800">
                                ${tag}
                                <button type="button" class="ml-1 text-orange-600 hover:text-orange-800" onclick="removeTag('${tag}')">
                                    <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20">
                                        <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>
                                    </svg>
                                </button>
                            </span>
                        `).join('')}
                    </div>
                    
                    <!-- Tag input with autocomplete -->
                    <div class="relative">
                        <input 
                            type="text" 
                            id="tagInput" 
                            placeholder="Digite para adicionar tags..."
                            class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                        >
                        <div id="tagSuggestions" class="absolute z-10 w-full mt-1 bg-white border border-gray-300 rounded-md shadow-lg hidden max-h-48 overflow-y-auto">
                            ${allTags.map(tag => `
                                <button type="button" class="tag-suggestion w-full text-left px-3 py-2 hover:bg-orange-50 text-sm" data-tag="${tag}">
                                    ${tag}
                                </button>
                            `).join('')}
                        </div>
                    </div>
                    
                    <p class="text-xs text-gray-500 mt-1">Clique nas sugestoes ou digite e pressione Enter</p>
                    
                    <!-- Hidden input to store tags -->
                    <input type="hidden" id="imageTags" value="${currentTags.join(',')}">
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Preview</label>
                    <img src="${image.url}" alt="${image.name}" class="w-full h-48 object-cover rounded-md border border-gray-300">
                </div>
                
                <div class="flex justify-end space-x-3 pt-4">
                    <button 
                        type="button" 
                        id="cancelBtn"
                        class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
                    >
                        Cancelar
                    </button>
                    <button 
                        type="submit" 
                        class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700"
                    >
                        Salvar Alteracoes
                    </button>
                </div>
            </form>
        `;
        
        this.view.showModal('Editar Imagem', formHtml);
        
        // Setup tag functionality
        this.tagsController.setupTagSystem();
        
        document.getElementById('imageEditForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.updateGalleryImage(image.id);
        });
        
        document.getElementById('cancelBtn').addEventListener('click', () => {
            this.view.closeModal();
        });
    }
    
    
    
    async updateGalleryImage(imageId) {
        const name = document.getElementById('imageName').value;
        const tagsInput = document.getElementById('imageTags').value;
        const tags = tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag);
        
        this.database.updateGalleryImage(imageId, { name, tags });
        this.view.showNotification('Imagem atualizada com sucesso!');
        this.view.closeModal();
        await this.galleryController.showGallery();
    }

    showImageUploadForm() {
        const formHtml = `
            <form id="imageUploadForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Selecionar Imagens</label>
                    <input 
                        type="file" 
                        id="imageFiles" 
                        multiple
                        accept="image/*"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md"
                    >
                    <p class="text-xs text-gray-500 mt-1">Pode selecionar múltiplas imagens (máx 5MB cada)</p>
                </div>
                
                <!-- Preview area for selected images -->
                <div id="imagePreviewArea" class="hidden">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Imagens Selecionadas</label>
                    <div id="imagePreviewList" class="grid grid-cols-4 gap-2 p-3 bg-gray-50 border border-gray-200 rounded-md max-h-32 overflow-y-auto">
                        <!-- Preview thumbnails will be added here -->
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Clique no ✕ para remover uma imagem</p>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Tags (opcional)</label>
                    <input 
                        type="text" 
                        id="imageTags" 
                        placeholder="comida, bebida, sobremesa (separado por vírgula)"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                    >
                </div>
                
                <div class="flex justify-end space-x-3 pt-4">
                    <button 
                        type="button" 
                        id="cancelBtn"
                        class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
                    >
                        Cancelar
                    </button>
                    <button 
                        type="submit" 
                        id="uploadSubmitBtn"
                        class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 disabled:opacity-50 disabled:cursor-not-allowed"
                        disabled
                    >
                        Upload Imagens
                    </button>
                </div>
            </form>
        `;
        
        this.view.showModal('Upload de Imagens', formHtml);
        
        // Initialize selected files storage
        this.selectedFiles = [];
        
        // Handle file selection
        document.getElementById('imageFiles').addEventListener('change', (e) => {
            this.handleFileSelection(e.target.files);
        });
        
        document.getElementById('imageUploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            await this.uploadImages();
        });
        
        document.getElementById('cancelBtn').addEventListener('click', () => {
            this.clearSelectedFiles();
            this.view.closeModal();
        });
    }
    
    handleFileSelection(files) {
        // Add new files to selected files array
        Array.from(files).forEach(file => {
            // Check file size
            if (file.size > 5000000) {
                alert(`Imagem ${file.name} muito grande! Máximo 5MB.`);
                return;
            }
            
            // Check if file already selected
            const alreadySelected = this.selectedFiles.some(f => 
                f.name === file.name && f.size === file.size && f.lastModified === file.lastModified
            );
            
            if (!alreadySelected) {
                this.selectedFiles.push(file);
            }
        });
        
        this.updateUploadImagePreview();
    }
    
    updateUploadImagePreview() {
        const previewArea = document.getElementById('imagePreviewArea');
        const previewList = document.getElementById('imagePreviewList');
        const submitBtn = document.getElementById('uploadSubmitBtn');
        
        if (this.selectedFiles.length === 0) {
            previewArea.classList.add('hidden');
            submitBtn.disabled = true;
            return;
        }
        
        previewArea.classList.remove('hidden');
        submitBtn.disabled = false;
        
        // Clear existing previews
        previewList.innerHTML = '';
        
        // Create preview for each file
        this.selectedFiles.forEach((file, index) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'relative group';
                previewItem.innerHTML = `
                    <div class="aspect-square bg-gray-100 rounded border overflow-hidden">
                        <img src="${e.target.result}" alt="${file.name}" class="w-full h-full object-cover">
                    </div>
                    <button 
                        type="button" 
                        class="absolute -top-1 -right-1 w-5 h-5 bg-red-500 text-white rounded-full text-xs font-bold hover:bg-red-600 flex items-center justify-center"
                        data-file-index="${index}"
                        title="Remover ${file.name}"
                    >
                        ✕
                    </button>
                    <p class="text-xs text-gray-600 mt-1 truncate" title="${file.name}">${file.name}</p>
                `;
                
                // Add remove functionality
                const removeBtn = previewItem.querySelector('button');
                removeBtn.addEventListener('click', () => {
                    this.removeSelectedFile(index);
                });
                
                previewList.appendChild(previewItem);
            };
            reader.readAsDataURL(file);
        });
    }
    
    removeSelectedFile(index) {
        this.selectedFiles.splice(index, 1);
        this.updateUploadImagePreview();
        
        // Update file input to reflect removed files
        this.updateFileInput();
    }
    
    updateFileInput() {
        const fileInput = document.getElementById('imageFiles');
        if (this.selectedFiles.length === 0) {
            fileInput.value = '';
        }
    }
    
    clearSelectedFiles() {
        this.selectedFiles = [];
        this.updateUploadImagePreview();
        this.updateFileInput();
    }

    showUrlUploadForm() {
        const formHtml = `
            <form id="urlUploadForm" class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">URL da Imagem</label>
                    <input 
                        type="url" 
                        id="imageUrl" 
                        placeholder="https://exemplo.com/imagem.jpg"
                        required
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                    >
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Nome da Imagem</label>
                    <input 
                        type="text" 
                        id="imageName" 
                        placeholder="Nome descritivo da imagem"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                    >
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Tags (opcional)</label>
                    <input 
                        type="text" 
                        id="imageTags" 
                        placeholder="comida, bebida, sobremesa (separado por vírgula)"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                    >
                </div>
                
                <div class="flex justify-end space-x-3 pt-4">
                    <button 
                        type="button" 
                        id="cancelBtn"
                        class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50"
                    >
                        Cancelar
                    </button>
                    <button 
                        type="submit" 
                        class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700"
                    >
                        Adicionar Imagem
                    </button>
                </div>
            </form>
        `;
        
        this.view.showModal('Adicionar Imagem por URL', formHtml);
        
        document.getElementById('urlUploadForm').addEventListener('submit', (e) => {
            e.preventDefault();
            this.uploadFromUrl();
        });
        
        document.getElementById('cancelBtn').addEventListener('click', () => {
            this.view.closeModal();
        });
    }

    async uploadImages() {
        const files = this.selectedFiles; // Use selected files from preview
        const tags = document.getElementById('imageTags').value.split(',').map(tag => tag.trim()).filter(tag => tag);
        
        if (!files.length) {
            alert('Selecione pelo menos uma imagem');
            return;
        }
        
        const uploadPromises = [];
        const previewCards = [];
        
        for (let file of files) {
            if (file.size > 5000000) {
                alert(`Imagem ${file.name} muito grande! Máximo 5MB.`);
                continue;
            }
            
            // Create immediate preview card
            const tempId = 'temp_' + Date.now() + '_' + Math.random();
            const previewCard = this.createUploadPreviewCard(file, tempId);
            previewCards.push({card: previewCard, file: file, tempId: tempId});
            
            // Add to gallery grid immediately
            const galleryGrid = document.getElementById('galleryGrid');
            if (galleryGrid) {
                galleryGrid.insertAdjacentHTML('afterbegin', previewCard);
            }
            
            // Start upload in background
            const uploadPromise = this.processImageUpload(file, tags, tempId);
            uploadPromises.push(uploadPromise);
        }
        
        // Wait for all uploads to complete
        try {
            await Promise.all(uploadPromises);
            this.view.showNotification('Todas as imagens foram adicionadas!', 'success');
        } catch (error) {
            console.error('❌ Alguns uploads falharam:', error);
        }
        
        this.view.closeModal();
    }
    
    createUploadPreviewCard(file, tempId) {
        // Create file URL for immediate preview
        const objectURL = URL.createObjectURL(file);
        
        return `
            <div class="gallery-image-card upload-preview relative group bg-gray-100 rounded-lg overflow-hidden aspect-square" data-temp-id="${tempId}">
                <!-- Upload progress overlay -->
                <div class="upload-overlay absolute inset-0 bg-blue-500 bg-opacity-75 flex items-center justify-center text-white font-semibold z-50 rounded">
                    <div class="text-center">
                        <svg class="animate-spin mx-auto mb-2 h-8 w-8" fill="none" viewBox="0 0 24 24">
                            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        <div class="text-sm">Enviando...</div>
                        <div class="text-xs opacity-75 mt-1">${file.name}</div>
                    </div>
                </div>
                
                <img src="${objectURL}" alt="Upload preview" class="w-full h-full object-cover">
            </div>
        `;
    }
    
    async processImageUpload(file, tags, tempId) {
        try {
            const imageData = await this.database.saveImage(file);
            const result = await this.database.addGalleryImage({
                name: file.name,
                url: imageData.url,
                size: file.size,
                type: file.type,
                tags: tags
            });
            
            // Replace preview card with real gallery card
            const previewCard = document.querySelector(`[data-temp-id="${tempId}"]`);
            if (previewCard && result) {
                // Create real gallery card
                const realCard = this.view.createGalleryImageCard({
                    id: result.id,
                    name: result.name,
                    url: result.url,
                    size: result.size,
                    type: result.type
                });
                
                // Replace with animation
                previewCard.style.transform = 'scale(0.9)';
                previewCard.style.transition = 'all 0.3s ease';
                
                setTimeout(() => {
                    previewCard.outerHTML = realCard;
                    // Re-attach event listeners for new card
                    this.setupGalleryEventListeners();
                }, 300);
            }
            
            return result;
            
        } catch (error) {
            console.error('❌ Upload falhou:', file.name, error);
            
            // Show error on preview card
            const previewCard = document.querySelector(`[data-temp-id="${tempId}"]`);
            if (previewCard) {
                const overlay = previewCard.querySelector('.upload-overlay');
                if (overlay) {
                    overlay.className = 'upload-overlay absolute inset-0 bg-red-500 bg-opacity-75 flex items-center justify-center text-white font-semibold z-50 rounded';
                    overlay.innerHTML = `
                        <div class="text-center">
                            <svg class="mx-auto mb-2 h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                            <div class="text-sm">Erro</div>
                            <div class="text-xs opacity-75">${error.message}</div>
                        </div>
                    `;
                }
                
                // Remove failed card after delay
                setTimeout(() => {
                    previewCard.style.transform = 'scale(0)';
                    previewCard.style.opacity = '0';
                    setTimeout(() => previewCard.remove(), 300);
                }, 2000);
            }
            
            throw error;
        }
    }

    async uploadFromUrl() {
        const url = document.getElementById('imageUrl').value;
        const name = document.getElementById('imageName').value || 'Imagem da URL';
        const tags = document.getElementById('imageTags').value.split(',').map(tag => tag.trim()).filter(tag => tag);
        
        try {
            await this.database.addGalleryImage({
                name: name,
                url: url,
                size: 0,
                type: 'image/jpeg',
                tags: tags
            });
            
            this.view.showNotification('Imagem adicionada com sucesso!');
        } catch (error) {
            console.error('❌ Erro ao adicionar imagem URL:', error);
            this.view.showNotification(`Erro ao adicionar imagem: ${error.message}`, 'error');
        }
        this.view.closeModal();
        await await this.galleryController.showGallery(); // Force refresh gallery
    }

    filterGalleryImages(search) {
        const images = this.database.getGalleryImages(search);
        const grid = document.getElementById('galleryGrid');
        
        if (grid) {
            grid.innerHTML = images.map(image => this.view.createGalleryImageCard(image)).join('');
            
            // Re-attach all event listeners
            
            // Image selection checkboxes (hidden, only for state)
            document.querySelectorAll('.image-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    this.galleryController.toggleImageSelection(e.target.dataset.imageId, e.target.checked);
                });
            });
            // Edit buttons
            document.querySelectorAll('.edit-image-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent event bubbling
                    const imageId = btn.dataset.imageId;
                    const image = this.database.getGalleryImageById(imageId);
                    if (image) {
                        this.showImageEditForm(image);
                    }
                });
            });
            
            // Delete buttons
            document.querySelectorAll('.delete-image-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent event bubbling
                    if (confirm('Tem certeza que deseja excluir esta imagem?')) {
                        this.database.deleteGalleryImage(btn.dataset.imageId);
                        this.view.showNotification('Imagem excluída com sucesso!');
                        await this.galleryController.showGallery();
                    }
                });
            });
        }
    }

    saveRestaurantSettings() {
        const restaurantData = {
            name: document.getElementById('restaurantName').value,
            logo: document.getElementById('restaurantLogo').value,
            banner: document.getElementById('restaurantBanner').value
        };
        
        this.database.updateRestaurant(restaurantData);
        this.view.showNotification('Configurações salvas com sucesso!');
    }

    setupDragAndDrop() {
        // Variáveis para controlar o drag
        let isDragging = false;
        let draggedElement = null;
        let startY = 0;
        let startX = 0;
        let placeholder = null;
        
        // Função para criar placeholder
        const createPlaceholder = () => {
            const placeholder = document.createElement('tr');
            placeholder.className = 'drag-placeholder';
            placeholder.innerHTML = `
                <td colspan="6" class="py-2 px-4">
                    <div class="border-2 border-dashed border-orange-400 bg-orange-50 rounded-lg p-2 text-center text-orange-600 text-sm">
                        ↕ Solte aqui para reordenar
                    </div>
                </td>
            `;
            return placeholder;
        };
        
        // Função para encontrar a linha mais próxima
        const findClosestRow = (y) => {
            const rows = document.querySelectorAll('.product-row:not(.dragging)');
            let closest = null;
            let closestDistance = Infinity;
            
            rows.forEach(row => {
                const rect = row.getBoundingClientRect();
                const distance = Math.abs(rect.top + rect.height / 2 - y);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closest = row;
                }
            });
            
            return closest;
        };
        
        // Mouse down no drag handle
        document.addEventListener('mousedown', (e) => {
            const dragHandle = e.target.closest('.drag-handle');
            if (!dragHandle) return;
            
            const row = dragHandle.closest('.product-row');
            if (!row) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            // Start drag immediately for better responsiveness
            startDrag(row, e.clientY, e.clientX);
        }, { passive: false });
        
        // Touch support
        document.addEventListener('touchstart', (e) => {
            const dragHandle = e.target.closest('.drag-handle');
            if (!dragHandle) return;
            
            const row = dragHandle.closest('.product-row');
            if (!row) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            // CRÍTICO: Bloquear scroll no mobile sem pular posição
            const scrollY = window.scrollY;
            document.body.style.overflow = 'hidden';
            document.body.style.position = 'fixed';
            document.body.style.top = `-${scrollY}px`;
            document.body.style.width = '100%';
            document.body.dataset.scrollY = scrollY;
            
            const touch = e.touches[0];
            startDrag(row, touch.clientY, touch.clientX);
        }, { passive: false });
        
        document.addEventListener('touchmove', (e) => {
            if (!isDragging || !draggedElement) return;
            
            // 🔧 FIX: Try-catch to handle passive event listener warning
            try {
                e.preventDefault();
                e.stopPropagation();
            } catch (error) {
                // Silently handle passive event listener restriction
            }
            
            // Scroll já bloqueado no touchstart, não precisa repetir
            
            const touch = e.touches[0];
            
            // Calcular nova posição baseada no movimento do touch
            const deltaY = touch.clientY - startY;
            const deltaX = touch.clientX - startX;
            
            const rect = draggedElement.getBoundingClientRect();
            const initialTop = parseInt(draggedElement.style.top) || rect.top;
            const initialLeft = parseInt(draggedElement.style.left) || rect.left;
            
            draggedElement.style.top = (initialTop + deltaY) + 'px';
            draggedElement.style.left = (initialLeft + deltaX) + 'px';
            
            startY = touch.clientY;
            startX = touch.clientX;
            
            // Encontrar linha mais próxima
            const closest = findClosestRow(touch.clientY);
            if (closest && closest.dataset.categoryId === draggedElement.dataset.categoryId) {
                const rect = closest.getBoundingClientRect();
                if (touch.clientY < rect.top + rect.height / 2) {
                    closest.parentNode.insertBefore(placeholder, closest);
                } else {
                    closest.parentNode.insertBefore(placeholder, closest.nextSibling);
                }
            }
        });
        
        document.addEventListener('touchend', (e) => {
            if (!isDragging || !draggedElement) return;
            finishDrag();
        });
        
        // Função para iniciar o drag
        const startDrag = (row, y, x) => {
            isDragging = true;
            draggedElement = row;
            
            // Pegar posição original da linha
            const rect = row.getBoundingClientRect();
            startY = y;
            startX = x;
            
            // Criar placeholder
            placeholder = createPlaceholder();
            
            // Estilo da linha sendo arrastada
            row.classList.add('dragging');
            row.style.position = 'fixed';
            row.style.top = (rect.top) + 'px';
            row.style.left = (rect.left) + 'px';
            row.style.width = rect.width + 'px';
            row.style.zIndex = '1000';
            row.style.pointerEvents = 'none';
            row.style.transform = 'rotate(2deg)';
            row.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
            row.style.backgroundColor = '#fff7ed';
            row.style.border = '2px solid #fb923c';
            
            // Inserir placeholder
            row.parentNode.insertBefore(placeholder, row.nextSibling);
            
            document.body.style.cursor = 'grabbing';
            document.body.style.userSelect = 'none';
        };
        
        // Mouse move
        document.addEventListener('mousemove', (e) => {
            if (!isDragging || !draggedElement) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            // CRÍTICO: Bloquear scroll da página durante drag
            document.body.style.overflow = 'hidden';
            
            // Calcular nova posição baseada no movimento do mouse
            const deltaY = e.clientY - startY;
            const deltaX = e.clientX - startX;
            
            // Aplicar movimento diretamente ao elemento
            const currentTop = parseFloat(draggedElement.style.top) || 0;
            const currentLeft = parseFloat(draggedElement.style.left) || 0;
            
            draggedElement.style.top = (currentTop + deltaY) + 'px';
            draggedElement.style.left = (currentLeft + deltaX) + 'px';
            
            // Atualizar as coordenadas de início para o próximo movimento
            startY = e.clientY;
            startX = e.clientX;
            
            // Encontrar linha mais próxima
            const closest = findClosestRow(e.clientY);
            if (closest && closest.dataset.categoryId === draggedElement.dataset.categoryId) {
                const rect = closest.getBoundingClientRect();
                if (e.clientY < rect.top + rect.height / 2) {
                    closest.parentNode.insertBefore(placeholder, closest);
                } else {
                    closest.parentNode.insertBefore(placeholder, closest.nextSibling);
                }
            }
        }, { passive: false });
        
        // Função para finalizar o drag
        const finishDrag = async () => {
            if (!isDragging || !draggedElement) return;
            
            isDragging = false;
            
            // Inserir elemento na posição do placeholder
            if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.insertBefore(draggedElement, placeholder);
                placeholder.remove();
            }
            
            // Resetar estilos
            draggedElement.classList.remove('dragging');
            draggedElement.style.position = '';
            draggedElement.style.zIndex = '';
            draggedElement.style.pointerEvents = '';
            draggedElement.style.transform = '';
            draggedElement.style.boxShadow = '';
            draggedElement.style.backgroundColor = '';
            draggedElement.style.border = '';
            draggedElement.style.top = '';
            draggedElement.style.left = '';
            draggedElement.style.width = '';
            
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            // CRÍTICO: Restaurar scroll na posição original (mobile)
            const scrollY = document.body.dataset.scrollY;
            document.body.style.overflow = '';
            document.body.style.position = '';
            document.body.style.top = '';
            document.body.style.width = '';
            document.body.style.userSelect = '';
            document.body.style.cursor = '';
            
            // Restaurar posição do scroll
            if (scrollY) {
                window.scrollTo(0, parseInt(scrollY));
                delete document.body.dataset.scrollY;
            }
            
            // Salvar nova ordem
            const categoryId = draggedElement.dataset.categoryId;
            const tbody = draggedElement.closest('tbody');
            const categoryRows = Array.from(tbody.querySelectorAll(`[data-category-id="${categoryId}"]`));
            const productIds = categoryRows.map(row => row.dataset.id);
            
            // Debug: mostrar nomes dos produtos para verificar ordem
            const productNames = categoryRows.map(row => row.querySelector('td:nth-child(3)')?.textContent?.trim());
            productNames.forEach((name, index) => {
            });
            try {
                await this.database.reorderProducts(categoryId, productIds);
                this.view.showNotification('Ordem atualizada!', 'success');
            } catch (error) {
                console.error('❌ Failed to save order:', error);
                this.view.showNotification('Erro ao salvar ordem!', 'error');
            }
            
            draggedElement = null;
            placeholder = null;
        };
        
        // Mouse up
        document.addEventListener('mouseup', (e) => {
            if (!isDragging || !draggedElement) return;
            finishDrag();
        });
    }

    setupCategoryDragAndDrop() {
        // Variáveis para controlar o drag
        let isDragging = false;
        let draggedElement = null;
        let startY = 0;
        let startX = 0;
        let placeholder = null;
        
        // Função para criar placeholder
        const createPlaceholder = () => {
            const placeholder = document.createElement('div');
            placeholder.className = 'drag-placeholder p-4 border border-gray-200 rounded-lg';
            placeholder.innerHTML = `
                <div class="border-2 border-dashed border-orange-400 bg-orange-50 rounded-lg p-2 text-center text-orange-600 text-sm">
                    ↕ Solte aqui para reordenar
                </div>
            `;
            return placeholder;
        };
        
        // Função para encontrar a linha mais próxima
        const findClosestRow = (y) => {
            const rows = document.querySelectorAll('.category-row:not(.dragging)');
            let closest = null;
            let closestDistance = Infinity;
            
            rows.forEach(row => {
                const rect = row.getBoundingClientRect();
                const distance = Math.abs(rect.top + rect.height / 2 - y);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closest = row;
                }
            });
            
            return closest;
        };
        
        // Mouse down no drag handle
        document.addEventListener('mousedown', (e) => {
            const dragHandle = e.target.closest('.drag-handle');
            if (!dragHandle) return;
            
            const row = dragHandle.closest('.category-row');
            if (!row) return;
            
            e.preventDefault();
            
            // Configurar drag após 200ms
            setTimeout(() => {
                if (e.buttons === 1) { // Verifica se ainda está pressionado
                    startDrag(row, e.clientY, e.clientX);
                }
            }, 200);
        });
        
        // Touch support
        document.addEventListener('touchstart', (e) => {
            const dragHandle = e.target.closest('.drag-handle');
            if (!dragHandle) return;
            
            const row = dragHandle.closest('.category-row');
            if (!row) return;
            
            e.preventDefault();
            
            const touch = e.touches[0];
            setTimeout(() => {
                startDrag(row, touch.clientY, touch.clientX);
            }, 200);
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!isDragging || !draggedElement) return;
            
            // 🔧 FIX: Try-catch to handle passive event listener warning  
            try {
                e.preventDefault();
            } catch (error) {
            }
            
            const touch = e.touches[0];
            
            // Calcular nova posição baseada no movimento do touch
            const deltaY = touch.clientY - startY;
            const deltaX = touch.clientX - startX;
            
            const rect = draggedElement.getBoundingClientRect();
            const initialTop = parseInt(draggedElement.style.top) || rect.top;
            const initialLeft = parseInt(draggedElement.style.left) || rect.left;
            
            draggedElement.style.top = (initialTop + deltaY) + 'px';
            draggedElement.style.left = (initialLeft + deltaX) + 'px';
            
            startY = touch.clientY;
            startX = touch.clientX;
            
            // Encontrar linha mais próxima
            const closest = findClosestRow(touch.clientY);
            if (closest) {
                const rect = closest.getBoundingClientRect();
                if (touch.clientY < rect.top + rect.height / 2) {
                    closest.parentNode.insertBefore(placeholder, closest);
                } else {
                    closest.parentNode.insertBefore(placeholder, closest.nextSibling);
                }
            }
        });
        
        document.addEventListener('touchend', (e) => {
            if (!isDragging || !draggedElement) return;
            finishDrag();
        });
        
        // Função para iniciar o drag
        const startDrag = (row, y, x) => {
            isDragging = true;
            draggedElement = row;
            
            // Pegar posição original da linha
            const rect = row.getBoundingClientRect();
            startY = y;
            startX = x;
            
            // Criar placeholder
            placeholder = createPlaceholder();
            
            // Estilo da linha sendo arrastada
            row.classList.add('dragging');
            row.style.position = 'fixed';
            row.style.top = (rect.top) + 'px';
            row.style.left = (rect.left) + 'px';
            row.style.width = rect.width + 'px';
            row.style.zIndex = '1000';
            row.style.pointerEvents = 'none';
            row.style.transform = 'rotate(2deg)';
            row.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3)';
            row.style.backgroundColor = '#fff7ed';
            row.style.border = '2px solid #fb923c';
            
            // Inserir placeholder
            row.parentNode.insertBefore(placeholder, row.nextSibling);
            
            document.body.style.cursor = 'grabbing';
            document.body.style.userSelect = 'none';
        };
        
        // Mouse move
        document.addEventListener('mousemove', (e) => {
            if (!isDragging || !draggedElement) return;
            
            e.preventDefault();
            
            // Calcular nova posição baseada no movimento do mouse
            const deltaY = e.clientY - startY;
            const deltaX = e.clientX - startX;
            
            // Pegar posição inicial e somar o delta
            const rect = draggedElement.getBoundingClientRect();
            const initialTop = parseInt(draggedElement.style.top) || rect.top;
            const initialLeft = parseInt(draggedElement.style.left) || rect.left;
            
            draggedElement.style.top = (initialTop + deltaY) + 'px';
            draggedElement.style.left = (initialLeft + deltaX) + 'px';
            
            // Atualizar as coordenadas de início para o próximo movimento
            startY = e.clientY;
            startX = e.clientX;
            
            // Encontrar linha mais próxima
            const closest = findClosestRow(e.clientY);
            if (closest) {
                const rect = closest.getBoundingClientRect();
                if (e.clientY < rect.top + rect.height / 2) {
                    closest.parentNode.insertBefore(placeholder, closest);
                } else {
                    closest.parentNode.insertBefore(placeholder, closest.nextSibling);
                }
            }
        });
        
        // Função para finalizar o drag
        const finishDrag = () => {
            if (!isDragging || !draggedElement) return;
            
            isDragging = false;
            
            // Inserir elemento na posição do placeholder
            if (placeholder && placeholder.parentNode) {
                placeholder.parentNode.insertBefore(draggedElement, placeholder);
                placeholder.remove();
            }
            
            // Resetar estilos
            draggedElement.classList.remove('dragging');
            draggedElement.style.position = '';
            draggedElement.style.zIndex = '';
            draggedElement.style.pointerEvents = '';
            draggedElement.style.transform = '';
            draggedElement.style.boxShadow = '';
            draggedElement.style.backgroundColor = '';
            draggedElement.style.border = '';
            draggedElement.style.top = '';
            draggedElement.style.left = '';
            draggedElement.style.width = '';
            
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            // Salvar nova ordem
            const container = draggedElement.closest('.space-y-4');
            const categoryRows = Array.from(container.querySelectorAll('.category-row'));
            const categoryIds = categoryRows.map(row => row.dataset.id);
            
            // Atualizar números dinamicamente
            categoryRows.forEach((row, index) => {
                const orderSpan = row.querySelector('span.text-gray-400');
                if (orderSpan) {
                    orderSpan.textContent = `#${index + 1}`;
                }
            });
            
            this.database.reorderCategories(categoryIds);
            this.view.showNotification('Ordem atualizada!', 'success');
            
            draggedElement = null;
            placeholder = null;
        };
        
        // Mouse up
        document.addEventListener('mouseup', (e) => {
            if (!isDragging || !draggedElement) return;
            finishDrag();
        });
    }

    renderCompactTagsSelector(selectedTags = []) {
        const availableTags = this.database.getProductTags();
        
        // If no tags from database, use fallback tags
        const tagsToShow = availableTags.length > 0 ? availableTags : [
            { id: "destaque", name: "Destaque", color: "#f59e0b", icon: "⭐" },
            { id: "mais-vendido", name: "Mais Vendido", color: "#ef4444", icon: "🔥" },
            { id: "especial-chef", name: "Especial do Chef", color: "#8b5cf6", icon: "👨‍🍳" },
            { id: "novo", name: "Novo", color: "#10b981", icon: "✨" },
            { id: "promocao", name: "Promoção", color: "#f97316", icon: "💰" }
        ];
        
        return `
            <div class="space-y-3">
                <!-- Compact Header with Expandable Tags -->
                <div class="bg-gray-50 rounded-lg p-3 border border-gray-200">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-3">
                            <span class="text-sm font-medium text-gray-700">Tags do Produto</span>
                            <button 
                                type="button" 
                                id="toggleTagsBtn"
                                class="text-orange-600 hover:text-orange-700 text-sm font-medium flex items-center gap-1 transition-colors"
                            >
                                <span>${tagsToShow.length} Tags Disponíveis</span>
                                <svg class="w-4 h-4 transition-transform" id="toggleTagsIcon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                </svg>
                            </button>
                        </div>
                        ${selectedTags.length > 0 ? `
                            <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded-full">
                                ${selectedTags.length} selecionada${selectedTags.length !== 1 ? 's' : ''}
                            </span>
                        ` : ''}
                    </div>
                </div>

                <!-- Tags Grid - Initially Hidden -->
                <div id="tagsGrid" class="hidden">
                    <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2">
                        ${tagsToShow.map(tag => {
                            const isSelected = selectedTags.includes(tag.id);
                            return `
                                <label class="group relative cursor-pointer transform transition-all duration-200 hover:scale-[1.02] active:scale-[0.98]">
                                    <input 
                                        type="checkbox" 
                                        name="productTags" 
                                        value="${tag.id}"
                                        ${isSelected ? 'checked' : ''}
                                        class="hidden tag-checkbox"
                                    >
                                    <div class="tag-card relative overflow-hidden rounded-xl border-2 transition-all duration-300 ${
                                        isSelected 
                                            ? 'border-transparent shadow-lg transform' 
                                            : 'border-gray-200 hover:border-gray-300 hover:shadow-md'
                                    }" 
                                    style="${isSelected ? `background: linear-gradient(135deg, ${tag.color}ee, ${tag.color});` : 'background: linear-gradient(135deg, #ffffff, #f8fafc);'}"
                                    data-color="${tag.color}">
                                        
                                        <!-- Selection Indicator - Top right -->
                                        <div class="absolute top-1 right-1 w-5 h-5 rounded-full border-2 transition-all duration-200 z-10 ${
                                            isSelected 
                                                ? 'bg-green-600 border-green-600 shadow-lg' 
                                                : 'border-gray-300 bg-white'
                                        }"${isSelected ? '' : ' style="background-color: rgba(255,255,255,0.9);"'}>
                                            ${isSelected ? `
                                                <div class="w-full h-full flex items-center justify-center">
                                                    <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                        <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                    </svg>
                                                </div>
                                            ` : ''}
                                        </div>

                                        <!-- Tag Content -->
                                        <div class="p-3 text-center">
                                            <div class="text-2xl mb-1 filter ${isSelected ? 'drop-shadow-sm' : ''}">${tag.icon}</div>
                                            <div class="text-xs font-semibold ${isSelected ? 'text-white' : 'text-gray-700'} truncate">${tag.name}</div>
                                        </div>
                                    </div>
                                </label>
                            `;
                        }).join('')}
                    </div>
                </div>
            </div>
        `;
    }

    renderTagsSelector(selectedTags = []) {
        const availableTags = this.database.getProductTags();
        
        // Debug log to see what tags are available
        
        // If no tags from database, use fallback tags
        const tagsToShow = availableTags.length > 0 ? availableTags : [
            { id: "destaque", name: "Destaque", color: "#f59e0b", icon: "⭐" },
            { id: "mais-vendido", name: "Mais Vendido", color: "#ef4444", icon: "🔥" },
            { id: "especial-chef", name: "Especial do Chef", color: "#8b5cf6", icon: "👨‍🍳" },
            { id: "novo", name: "Novo", color: "#10b981", icon: "✨" },
            { id: "promocao", name: "Promoção", color: "#f97316", icon: "💰" }
        ];
        
        return `
            <div class="space-y-4">
                <!-- Section Header -->
                <div class="flex items-center justify-between">
                    <div class="flex items-center space-x-2">
                        <div class="w-2 h-2 bg-gradient-to-r from-blue-500 to-purple-500 rounded-full"></div>
                        <span class="text-sm font-medium text-gray-700">Tags Disponíveis</span>
                        <span class="text-xs text-gray-400">(${selectedTags.length} selecionada${selectedTags.length !== 1 ? 's' : ''})</span>
                    </div>
                </div>

                <!-- Tags Grid - Modern Layout -->
                <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-2">
                    ${tagsToShow.map(tag => {
                        const isSelected = selectedTags.includes(tag.id);
                        return `
                            <label class="group relative cursor-pointer transform transition-all duration-200 hover:scale-[1.02] active:scale-[0.98]">
                                <input 
                                    type="checkbox" 
                                    name="productTags" 
                                    value="${tag.id}"
                                    ${isSelected ? 'checked' : ''}
                                    class="hidden tag-checkbox"
                                >
                                <div class="tag-card relative overflow-hidden rounded-xl border-2 transition-all duration-300 ${
                                    isSelected 
                                        ? 'border-transparent shadow-lg transform' 
                                        : 'border-gray-200 hover:border-gray-300 hover:shadow-md'
                                }" 
                                style="${isSelected ? `background: linear-gradient(135deg, ${tag.color}ee, ${tag.color});` : 'background: linear-gradient(135deg, #ffffff, #f8fafc);'}"
                                data-color="${tag.color}">
                                    
                                    <!-- Delete Button - Always visible, top left -->
                                    <button 
                                        type="button" 
                                        class="delete-tag-btn absolute top-1 left-1 w-5 h-5 bg-red-500 hover:bg-red-600 text-white rounded-full transition-all duration-200 flex items-center justify-center shadow-md"
                                        data-tag-id="${tag.id}"
                                        title="Deletar tag"
                                    >
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                                        </svg>
                                    </button>
                                    
                                    <!-- Selection Indicator - Top right -->
                                    <div class="absolute top-1 right-1 w-5 h-5 rounded-full border-2 transition-all duration-200 z-10 ${
                                        isSelected 
                                            ? 'bg-green-600 border-green-600 shadow-lg' 
                                            : 'border-gray-300 bg-white'
                                    }"${isSelected ? '' : ' style="background-color: rgba(255,255,255,0.9);"'}>
                                        ${isSelected ? `
                                            <div class="w-full h-full flex items-center justify-center">
                                                <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                                </svg>
                                            </div>
                                        ` : ''}
                                    </div>

                                    <!-- Tag Content -->
                                    <div class="p-3 text-center">
                                        <div class="text-2xl mb-1 filter ${isSelected ? 'drop-shadow-sm' : ''}">${tag.icon}</div>
                                        <div class="text-xs font-semibold ${isSelected ? 'text-white' : 'text-gray-700'} truncate">${tag.name}</div>
                                    </div>

                                    <!-- Hover Overlay -->
                                    <div class="absolute inset-0 bg-gradient-to-t from-black/10 to-transparent opacity-0 group-hover:opacity-100 transition-opacity duration-200 pointer-events-none"></div>
                                </div>
                            </label>
                        `;
                    }).join('')}
                    
                    <!-- Add Custom Tag Card -->
                    <div class="tag-add-card group cursor-pointer transform transition-all duration-200 hover:scale-[1.02] active:scale-[0.98]" id="addCustomTagCard">
                        <div class="h-full rounded-xl border-2 border-dashed border-gray-300 bg-gradient-to-br from-gray-50 to-white p-3 text-center transition-all duration-300 group-hover:border-orange-400 group-hover:bg-gradient-to-br group-hover:from-orange-50 group-hover:to-orange-100 group-hover:shadow-md">
                            <div class="flex flex-col items-center justify-center h-full space-y-1">
                                <div class="w-8 h-8 rounded-full bg-gray-200 group-hover:bg-orange-200 transition-colors duration-200 flex items-center justify-center">
                                    <svg class="w-4 h-4 text-gray-400 group-hover:text-orange-500 transition-colors duration-200" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
                                    </svg>
                                </div>
                                <span class="text-xs font-medium text-gray-500 group-hover:text-orange-600 transition-colors duration-200">Nova Tag</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Custom Tag Creation Panel -->
                <div id="customTagSection" class="hidden">
                    <div class="bg-gradient-to-r from-orange-50 via-orange-50 to-yellow-50 rounded-2xl border border-orange-200 p-6 shadow-sm">
                        <!-- Header -->
                        <div class="flex items-center justify-between mb-4">
                            <div class="flex items-center space-x-3">
                                <div class="w-10 h-10 bg-gradient-to-r from-orange-400 to-orange-500 rounded-xl flex items-center justify-center shadow-lg">
                                    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"></path>
                                    </svg>
                                </div>
                                <div>
                                    <h3 class="text-lg font-semibold text-gray-800">Criar Tag Personalizada</h3>
                                    <p class="text-sm text-gray-600">Defina um nome, emoji e cor para sua nova tag</p>
                                </div>
                            </div>
                            <button type="button" id="cancelCreateTag" class="text-gray-400 hover:text-gray-600 transition-colors">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                                </svg>
                            </button>
                        </div>

                        <!-- Form Fields -->
                        <div class="space-y-4 mb-6">
                            <!-- Name Field -->
                            <div class="space-y-2">
                                <label class="block text-sm font-medium text-gray-700">
                                    Nome da Tag *
                                </label>
                                <div class="relative">
                                    <input 
                                        type="text" 
                                        id="customTagName" 
                                        placeholder="Ex: Super Especial, Favorito dos Clientes..."
                                        class="w-full px-4 py-3 bg-white border border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-200 placeholder-gray-400"
                                        maxlength="20"
                                    >
                                    <div class="absolute inset-y-0 right-0 flex items-center pr-3">
                                        <span class="text-xs text-gray-400" id="nameCounter">0/20</span>
                                    </div>
                                </div>
                            </div>

                            <!-- Icon and Color Row -->
                            <div class="grid grid-cols-2 gap-4">
                                <!-- Icon Field -->
                                <div class="space-y-2">
                                    <label class="block text-sm font-medium text-gray-700">
                                        Emoji
                                    </label>
                                    <div class="relative">
                                        <input 
                                            type="text" 
                                            id="customTagIcon" 
                                            placeholder="🔥"
                                            maxlength="2"
                                            class="w-full px-4 py-3 bg-white border border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-200 text-center text-lg placeholder-gray-400"
                                        >
                                        <div class="absolute inset-y-0 right-0 flex items-center pr-3">
                                            <button type="button" class="text-xs text-orange-600 hover:text-orange-700 font-medium" onclick="document.getElementById('customTagIcon').value = ['🔥','⭐','✨','👑','💎','🎯','🚀','❤️','🌟','🏆'][Math.floor(Math.random()*10)]">
                                                Aleatório
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Color Field -->
                                <div class="space-y-2">
                                    <label class="block text-sm font-medium text-gray-700">
                                        Cor
                                    </label>
                                    <div class="relative">
                                        <input 
                                            type="color" 
                                            id="customTagColor" 
                                            value="#6366f1"
                                            class="w-full h-12 bg-white border border-gray-200 rounded-xl focus:outline-none focus:ring-2 focus:ring-orange-500 focus:border-transparent transition-all duration-200 cursor-pointer"
                                        >
                                        <!-- Color Presets -->
                                        <div class="absolute top-full mt-2 flex space-x-1">
                                            ${['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#6b7280'].map(color => `
                                                <button type="button" class="w-6 h-6 rounded-full border-2 border-white shadow-sm hover:scale-110 transition-transform" 
                                                        style="background-color: ${color}" 
                                                        onclick="document.getElementById('customTagColor').value = '${color}'"></button>
                                            `).join('')}
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Preview -->
                            <div class="space-y-2 mb-5">
                                <label class="block text-sm font-medium text-gray-700">
                                    Preview
                                </label>
                                <div class="flex items-center space-x-3 p-4 bg-white rounded-xl border border-gray-200">
                                    <span class="text-sm text-gray-600">Sua tag ficará assim:</span>
                                    <div id="tagPreview" class="px-3 py-1.5 text-sm font-medium rounded-full border-2 border-gray-300 text-gray-700">
                                        🏷️ Nova Tag
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Action Buttons -->
                        <div class="flex items-center justify-end space-x-3">
                            <button 
                                type="button" 
                                id="cancelCreateTagAlt"
                                class="px-6 py-2.5 text-sm font-medium text-gray-600 bg-white border border-gray-200 rounded-xl hover:bg-gray-50 hover:border-gray-300 transition-all duration-200"
                            >
                                Cancelar
                            </button>
                            <button 
                                type="button" 
                                id="confirmCreateTag"
                                class="px-6 py-2.5 text-sm font-semibold text-white bg-gradient-to-r from-orange-500 to-orange-600 rounded-xl hover:from-orange-600 hover:to-orange-700 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 transform transition-all duration-200 hover:scale-[1.02] active:scale-[0.98] shadow-lg hover:shadow-xl disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled
                            >
                                <svg class="w-4 h-4 mr-2 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                </svg>
                                Criar Tag
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    setupTagsEvents() {
        // Toggle tags visibility
        const toggleBtn = document.getElementById('toggleTagsBtn');
        const tagsGrid = document.getElementById('tagsGrid');
        const toggleIcon = document.getElementById('toggleTagsIcon');
        
        if (toggleBtn && tagsGrid && toggleIcon) {
            toggleBtn.addEventListener('click', () => {
                const isHidden = tagsGrid.classList.contains('hidden');
                
                if (isHidden) {
                    tagsGrid.classList.remove('hidden');
                    toggleIcon.style.transform = 'rotate(180deg)';
                } else {
                    tagsGrid.classList.add('hidden');
                    toggleIcon.style.transform = 'rotate(0deg)';
                }
            });
        }
        
        // Toggle tag selection with improved visual feedback
        document.querySelectorAll('.tag-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const tagCard = e.target.nextElementSibling;
                const color = tagCard.dataset.color;
                const isSelected = e.target.checked;
                
                // Update card background
                if (isSelected) {
                    tagCard.style.background = `linear-gradient(135deg, ${color}ee, ${color})`;
                    tagCard.classList.add('border-transparent', 'shadow-lg');
                    tagCard.classList.remove('border-gray-200');
                } else {
                    tagCard.style.background = 'linear-gradient(135deg, #ffffff, #f8fafc)';
                    tagCard.classList.remove('border-transparent', 'shadow-lg');
                    tagCard.classList.add('border-gray-200');
                }
                
                // Update selection indicator circle
                const selectionIndicator = tagCard.querySelector('.absolute.top-1.right-1');
                if (selectionIndicator) {
                    if (isSelected) {
                        selectionIndicator.className = 'absolute top-1 right-1 w-5 h-5 rounded-full border-2 transition-all duration-200 z-10 bg-green-600 border-green-600 shadow-lg';
                        selectionIndicator.innerHTML = `
                            <div class="w-full h-full flex items-center justify-center">
                                <svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20">
                                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                </svg>
                            </div>
                        `;
                    } else {
                        selectionIndicator.className = 'absolute top-1 right-1 w-5 h-5 rounded-full border-2 transition-all duration-200 z-10 border-gray-300 bg-white';
                        selectionIndicator.style.backgroundColor = 'rgba(255,255,255,0.9)';
                        selectionIndicator.innerHTML = '';
                    }
                }
                
                // Update counter
                this.updateTagCounter();
            });
        });
        
        // Delete tag buttons
        document.querySelectorAll('.delete-tag-btn').forEach(deleteBtn => {
            deleteBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation(); // Prevent tag selection when clicking delete
                
                const tagId = deleteBtn.dataset.tagId;
                this.confirmDeleteTag(tagId);
            });
        });
        
        // Add custom tag card click
        const addCustomTagCard = document.getElementById('addCustomTagCard');
        if (addCustomTagCard) {
            addCustomTagCard.addEventListener('click', () => {
                const customTagSection = document.getElementById('customTagSection');
                customTagSection.classList.remove('hidden');
                
                // Smooth scroll to the form
                setTimeout(() => {
                    customTagSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    document.getElementById('customTagName').focus();
                }, 100);
            });
        }
        
        // Create custom tag
        const confirmCreateTag = document.getElementById('confirmCreateTag');
        if (confirmCreateTag) {
            confirmCreateTag.addEventListener('click', async () => {
                await this.createCustomTag();
            });
        }
        
        // Cancel custom tag (multiple buttons)
        ['cancelCreateTag', 'cancelCreateTagAlt'].forEach(id => {
            const cancelBtn = document.getElementById(id);
            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => {
                    document.getElementById('customTagSection').classList.add('hidden');
                    this.clearCustomTagForm();
                });
            }
        });
        
        // ✅ SIMPLE DIRECT TAG PREVIEW (no complex components)
        this.setupSimpleTagPreview();
        
        // Enter key handlers
        const customTagName = document.getElementById('customTagName');
        const customTagIcon = document.getElementById('customTagIcon');
        
        if (customTagName && customTagIcon) {
            [customTagName, customTagIcon].forEach(input => {
                input.addEventListener('keypress', async (e) => {
                    if (e.key === 'Enter') {
                        const confirmBtn = document.getElementById('confirmCreateTag');
                        if (confirmBtn && !confirmBtn.disabled) {
                            await this.createCustomTag();
                        }
                    }
                });
            });
        }
    }
    
    /**
     * Setup simple tag preview that ALWAYS works (NASA: simple solution)
     * Function size: 35 lines (NASA compliant)
     */
    setupSimpleTagPreview() {
        const nameField = document.getElementById('customTagName');
        const emojiField = document.getElementById('customTagIcon');
        const colorField = document.getElementById('customTagColor');
        const preview = document.getElementById('tagPreview');
        const confirmBtn = document.getElementById('confirmCreateTag');
        
        if (!nameField || !emojiField || !colorField || !preview) {
            return;
        }
        
        // Simple update function that ALWAYS works
        const updatePreview = () => {
            const name = nameField.value.trim() || 'Nova Tag';
            const emoji = emojiField.value.trim() || '🏷️';
            const color = colorField.value || '#3b82f6';
            
            // Update preview with current values
            preview.innerHTML = `
                <span class="inline-flex items-center gap-2 px-3 py-1.5 rounded-lg" 
                      style="background-color: ${color}; color: white;">
                    <span>${emoji}</span>
                    <span class="font-medium">${name}</span>
                </span>
            `;
            
            // Update button state
            if (confirmBtn) {
                confirmBtn.disabled = !nameField.value.trim();
            }
        };
        
        // Bind ALL events to ALL fields
        [nameField, emojiField, colorField].forEach(field => {
            field.addEventListener('input', updatePreview);
            field.addEventListener('change', updatePreview);
            field.addEventListener('keyup', updatePreview);
            field.addEventListener('blur', updatePreview);
        });
        
        // ✅ DIRECT CLICK DETECTION: Detectar cliques nos pickers específicos
        this.setupDirectClickDetection(updatePreview);
        
        // Initial update
        updatePreview();
    }
    
    /**
     * Setup direct click detection (NASA: simple solution)
     * Function size: 25 lines (NASA compliant)
     */
    setupDirectClickDetection(updateCallback) {
        // NASA Standard: Single responsibility - apenas detectar cliques
        document.addEventListener('click', (event) => {
            const target = event.target;
            const tagSection = document.getElementById('customTagSection');
            
            // Verificar se clique foi dentro da seção de tags
            if (!tagSection || !tagSection.contains(target)) {
                return; // NASA: Early return para reduzir complexidade
            }
            
            // Detectar cliques nos pickers específicos
            const emojiContainer = target.closest('#customTagSection > div > div.space-y-4.mb-6 > div.grid.grid-cols-2.gap-4 > div:nth-child(1) > div > div');
            const colorContainer = target.closest('#customTagSection > div > div.space-y-4.mb-6 > div.grid.grid-cols-2.gap-4 > div:nth-child(2) > div > div');
            
            if (emojiContainer || colorContainer) {
                setTimeout(updateCallback, 50); // NASA: Minimal delay
            }
        });
    }
    
    /**
     * Clear custom tag form (NASA: form management)
     * Function size: 15 lines (NASA compliant)
     */
    clearCustomTagForm() {
        const nameField = document.getElementById('customTagName');
        const emojiField = document.getElementById('customTagIcon');
        const colorField = document.getElementById('customTagColor');
        
        if (nameField) nameField.value = '';
        if (emojiField) emojiField.value = '🏷️';
        if (colorField) colorField.value = '#3b82f6';
        
        // Trigger preview update
        this.setupSimpleTagPreview();
    }
    
    updateTagCounter() {
        const selectedCount = document.querySelectorAll('.tag-checkbox:checked').length;
        const counterElement = document.querySelector('.text-xs.text-gray-400');
        if (counterElement) {
            counterElement.textContent = `(${selectedCount} selecionada${selectedCount !== 1 ? 's' : ''})`;
        }
    }

    async createCustomTag() {
        const name = document.getElementById('customTagName').value.trim();
        const icon = document.getElementById('customTagIcon').value.trim() || '🏷️';
        const color = document.getElementById('customTagColor').value;
        
        if (!name) {
            this.view.showNotification('Nome da tag é obrigatório', 'error');
            return;
        }
        
        try {
            
            // Show loading state
            const confirmBtn = document.getElementById('confirmCreateTag');
            const originalText = confirmBtn.textContent;
            confirmBtn.textContent = 'Criando...';
            confirmBtn.disabled = true;
            
            const newTag = await this.database.addProductTag({ name, icon, color });
            
            // Try to refresh tags container safely
            try {
                const container = document.getElementById('productTagsContainer');
                if (container) {
                    const currentTags = this.tagsController.getSelectedTags();
                    container.innerHTML = this.tagsController.renderCompactTagsSelector(currentTags);
                    this.tagsController.setupTagsEvents();
                }
            } catch (uiError) {
                // Don't throw - tag was created successfully in database
            }
            
            // Hide custom tag section and clear form
            document.getElementById('customTagSection').classList.add('hidden');
            this.clearCustomTagForm();
            
            this.view.showNotification(`Tag "${name}" criada com sucesso!`);
            
        } catch (error) {
            console.error('❌ Error creating tag:', error);
            this.view.showNotification(`Erro ao criar tag: ${error.message}`, 'error');
            
            // Restore button state
            const confirmBtn = document.getElementById('confirmCreateTag');
            if (confirmBtn) {
                confirmBtn.textContent = 'Criar Tag';
                confirmBtn.disabled = false;
            }
        }
    }

    getSelectedTags() {
        const checkboxes = document.querySelectorAll('.tag-checkbox:checked');
        return Array.from(checkboxes).map(cb => cb.value);
    }

    confirmDeleteTag(tagId) {
        const tag = this.database.getProductTags().find(t => t.id === tagId);
        if (!tag) return;
        
        // Check how many products use this tag
        const products = this.database.getProducts();
        const productsWithTag = products.filter(p => p.tags && p.tags.includes(tagId));
        
        const warningMessage = productsWithTag.length > 0 
            ? `Esta tag será removida de ${productsWithTag.length} produto${productsWithTag.length > 1 ? 's' : ''}.` 
            : '';
        
        const confirmMessage = `
            <div class="text-center space-y-4">
                <div class="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto">
                    <svg class="w-8 h-8 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                    </svg>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold text-gray-900 mb-2">Deletar Tag</h3>
                    <p class="text-gray-600 mb-2">
                        Tem certeza que deseja deletar a tag 
                        <span class="inline-flex items-center px-2 py-1 rounded-full text-sm font-medium text-white" 
                              style="background-color: ${tag.color};">
                            ${tag.icon} ${tag.name}
                        </span>?
                    </p>
                    ${warningMessage ? `<p class="text-orange-600 text-sm font-medium">${warningMessage}</p>` : ''}
                </div>
                
                <div class="flex justify-center space-x-3 pt-4">
                    <button 
                        type="button" 
                        id="confirmDeleteTagBtn"
                        class="px-6 py-2 text-sm font-medium text-gray-600 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors"
                        data-tag-id="${tagId}"
                    >
                        Sim, Deletar
                    </button>
                    <button 
                        type="button" 
                        id="cancelDeleteTag"
                        class="px-6 py-2 text-sm font-semibold text-white bg-orange-600 rounded-lg hover:bg-orange-700 transition-colors"
                    >
                        Cancelar
                    </button>
                </div>
            </div>
        `;
        
        this.view.showModal('Confirmar Exclusão', confirmMessage, true);
        
        // Handle confirmation
        document.getElementById('confirmDeleteTagBtn').addEventListener('click', () => {
            this.deleteTag(tagId);
        });
        
        document.getElementById('cancelDeleteTag').addEventListener('click', () => {
            this.view.closeModal(true);
        });
    }

    deleteTag(tagId) {
        try {
            this.database.deleteProductTag(tagId);
            
            // Refresh tags container
            const container = document.getElementById('productTagsContainer');
            const currentTags = this.tagsController.getSelectedTags().filter(t => t !== tagId); // Remove deleted tag from selection
            container.innerHTML = this.tagsController.renderCompactTagsSelector(currentTags);
            this.tagsController.setupTagsEvents();
            
            this.view.closeModal(true);
            this.view.showNotification('Tag deletada com sucesso!');
        } catch (error) {
            this.view.showNotification('Erro ao deletar tag: ' + error.message, 'error');
        }
    }

    // ===== MÉTODOS DE OTIMIZAÇÃO DE IMAGENS =====

    /**
     * Configurar funcionalidades de otimização de imagens
     */

    /**
     * Configurar eventos da otimização
     */

    /**
     * Atualizar contagem de imagens
     */

    /**
     * Iniciar processo de otimização
     */

    /**
     * Atualizar progress bar
     */

    /**
     * Mostrar resultados da otimização
     */

    /**
     * Toggle lista de backups
     */

    /**
     * Atualizar lista de backups
     */

    /**
     * Restaurar backup
     */

    /**
     * Formatar tamanho de arquivo
     */
}